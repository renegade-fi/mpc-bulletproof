#![allow(non_snake_case)]
//! Definition of the proof struct.

use mpc_stark::algebra::scalar::ScalarResult;
use mpc_stark::algebra::stark_curve::StarkPointResult;
use tokio::runtime::Handle;

use crate::errors::MultiproverError;
use crate::r1cs::R1CSProof;

use super::mpc_inner_product::SharedInnerProductProof;

/// A proof generated by a distributed prover; i.e. across multiple machines participating
/// in a multiparty computation.
///
/// The proof is partially shared, as many of the values are opened during protocol execution
/// to keep the transcript consistent between the parties in a simple manner
#[derive(Clone, Debug)]
#[allow(non_snake_case)]
pub struct PartiallySharedR1CSProof {
    /// Commitment to the values of input wires in the first phase.
    pub(super) A_I1: StarkPointResult,
    /// Commitment to the values of output wires in the first phase.
    pub(super) A_O1: StarkPointResult,
    /// Commitment to the blinding factors in the first phase.
    pub(super) S1: StarkPointResult,
    /// Commitment to the values of input wires in the second phase.
    pub(super) A_I2: StarkPointResult,
    /// Commitment to the values of output wires in the second phase.
    pub(super) A_O2: StarkPointResult,
    /// Commitment to the blinding factors in the second phase.
    pub(super) S2: StarkPointResult,
    /// Commitment to the \\(t_1\\) coefficient of \\( t(x) \\)
    pub(super) T_1: StarkPointResult,
    /// Commitment to the \\(t_3\\) coefficient of \\( t(x) \\)
    pub(super) T_3: StarkPointResult,
    /// Commitment to the \\(t_4\\) coefficient of \\( t(x) \\)
    pub(super) T_4: StarkPointResult,
    /// Commitment to the \\(t_5\\) coefficient of \\( t(x) \\)
    pub(super) T_5: StarkPointResult,
    /// Commitment to the \\(t_6\\) coefficient of \\( t(x) \\)
    pub(super) T_6: StarkPointResult,
    /// Evaluation of the polynomial \\(t(x)\\) at the challenge point \\(x\\)
    pub(super) t_x: ScalarResult,
    /// Blinding factor for the synthetic commitment to \\( t(x) \\)
    pub(super) t_x_blinding: ScalarResult,
    /// Blinding factor for the synthetic commitment to the
    /// inner-product arguments
    pub(super) e_blinding: ScalarResult,
    /// Proof data for the inner-product argument.
    /// Made public for integration tests to test malleability
    #[cfg(not(feature = "integration_test"))]
    pub(super) ipp_proof: SharedInnerProductProof,
    #[cfg(feature = "integration_test")]
    pub ipp_proof: SharedInnerProductProof,
}

impl PartiallySharedR1CSProof {
    /// Opens the proof, generating a standard R1CS Proof
    pub fn open(&self) -> Result<R1CSProof, MultiproverError> {
        // To open, only the inner product proof must be opened
        // Every other value is opened during the course of proof generation to maintain
        // a consistent Merlin transcript
        let ipp_open = self.ipp_proof.open()?;

        macro_rules! await_res {
            ($res:expr) => {
                Handle::current().block_on($res)
            };
        }

        Ok(R1CSProof {
            A_I1: await_res!(self.A_I1.clone()),
            A_O1: await_res!(self.A_O1.clone()),
            S1: await_res!(self.S1.clone()),
            A_I2: await_res!(self.A_I2.clone()),
            A_O2: await_res!(self.A_O2.clone()),
            S2: await_res!(self.S2.clone()),
            T_1: await_res!(self.T_1.clone()),
            T_3: await_res!(self.T_3.clone()),
            T_4: await_res!(self.T_4.clone()),
            T_5: await_res!(self.T_5.clone()),
            T_6: await_res!(self.T_6.clone()),
            t_x: await_res!(self.t_x.clone()),
            t_x_blinding: await_res!(self.t_x_blinding.clone()),
            e_blinding: await_res!(self.e_blinding.clone()),
            ipp_proof: ipp_open,
        })
    }
}
